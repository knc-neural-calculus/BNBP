<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>BNBP-public.HH-SGD.psweep.plot_psweep API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>BNBP-public.HH-SGD.psweep.plot_psweep</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import sys
import math
from typing import *
from types import FunctionType

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

sys.path.append(&#34;..&#34;)
sys.path.append(&#34;HH-SGD&#34;)

from psweep.psweep import *


def fcomp(a,b,delta = 1e-5):
        return abs(a-b) &lt; delta


def load_pickled(filename = &#39;data.df&#39;):
        return pd.read_pickle(filename)



class FloatSet(set):
        def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)

        def add_float(self, myfloat : float, delta = 1e-5):
                if all( (not fcomp(x, myfloat, delta)) for x in self ):
                        self.add(myfloat)
        

def compute_ranges(
                df,
                cols_ignore = REMOVE_COLS + [&#39;CONFIG_ID&#39;, &#39;DIRNAME&#39;] + [ k for k in LOSS_TYPES ],
                typemap = TYPE_MAP,
        ):
        &#34;&#34;&#34;
        takes in a dataframe, returns a 2-tuple of dicts:
        (variable_ranges, consts)
        &#34;&#34;&#34;
        
        # get all unique elements in each column
        ranges = {}
        for col in df.columns:
                if col not in cols_ignore:
                        is_floatCol = isinstance( typemap[col], float)
                        if is_floatCol:
                                ranges[col] = FloatSet()
                        else:
                                ranges[col] = set()
                        
                        for x in df[col]:
                                if is_floatCol:
                                        ranges[col].add_float(x)
                                else:
                                        ranges[col].add(x)

        var_ranges : Dict[str, List[float]] = {}
        consts : Dict[str, float] = {}

        for k in ranges:
                if len(ranges[k]) == 1:
                        # not variable
                        consts[k] = ranges[k].pop()
                else:
                        # variable
                        var_ranges[k] = sorted(list(ranges[k]))

        return (var_ranges, consts)





def save_sorted_many(df, basepath = &#39;&#39;):
        pd.set_option(&#39;display.max_rows&#39;, None)
        pd.set_option(&#39;display.max_columns&#39;, 50)
        pd.set_option(&#39;display.width&#39;, None)
        pd.set_option(&#39;display.max_colwidth&#39;, 500)

        with open(basepath + &#39;loss_rel.txt&#39;, &#39;w&#39;) as fout:
                print(df.sort_values(&#39;LOSS_REL&#39;), file=fout)

        with open(basepath + &#39;loss_abs.txt&#39;, &#39;w&#39;) as fout:
                print(df.sort_values(&#39;LOSS_ABS&#39;), file=fout)

        with open(basepath + &#39;test_acc.txt&#39;, &#39;w&#39;) as fout:
                print(df.sort_values(&#39;TEST_ACCURACY&#39;), file=fout)

def save_sorted(df : pd.DataFrame, path : str = &#39;&#39;, sort_col : str = &#39;TEST_ACCURACY&#39;):
        with open(path, &#39;w&#39;) as fout:
                print(df.sort_values(sort_col), file=fout)


def plot_pair_heatmap(
                data,
                X, Y,
                others,
                ranges = None,
                # defaults = None,
                accuracy_mode = &#39;LOSS_REL&#39;,
        ):

        if ranges is None:
                ranges = compute_ranges(data)[0]

        print(ranges)
        
        # if defaults is None:
        #       defaults = CONSTS_DEFAULT


        # * trimming input dataframe

        # for everything in `others`, delete all dataframe elements that dont match
        for k in others:
                data = data.loc[ fcomp(data[k], others[k]) ]

        # dont need config ID or any of the default values
        del data[&#39;CONFIG_ID&#39;]

        for ot in others:
                del data[ot]

        # only need 1 type of loss
        for lt in LOSS_TYPES:
                if lt != accuracy_mode:
                        del data[lt]
        
        data_im = np.full(
                ( len(ranges[Y]), len(ranges[X]) ),
                np.nan,
                dtype=np.float
        )

        print(data)

        for i,x in enumerate(ranges[X]):
                for j,y in enumerate(ranges[Y]):
                        temp = data.loc[
                                fcomp(data[X], x)
                                &amp; fcomp(data[Y], y)
                        ][accuracy_mode]

                        if temp.empty:
                                data_im[j,i] = np.nan
                        else:
                                data_im[j,i] = temp.to_list()[0]                        
                        
        # * chart stuff

        x_vals = ranges[X]
        y_vals = ranges[Y]

        fig, ax = plt.subplots()
        im = ax.imshow(data_im, cmap=&#34;inferno&#34;)
        cbar = plt.colorbar(im)
        cbar.ax.set_ylabel(accuracy_mode, rotation=-90, va=&#34;bottom&#34;)

        # We want to show all ticks...
        ax.set_xticks(np.arange(len(x_vals)))
        ax.set_yticks(np.arange(len(y_vals)))

        # ... and label them with the respective list entries
        ax.set_xticklabels([str(round(x_vals[i], 2)) if (i == len(x_vals) - 1 or i % 5 == 0) else &#34;&#34; for i in range(len(x_vals))])
        ax.set_yticklabels([str(round(y_vals[i], 2)) if (i == len(y_vals) - 1 or i % 5 == 0) else &#34;&#34; for i in range(len(y_vals))])

        # Rotate the tick labels and set their alignment.
        plt.setp(ax.get_xticklabels(), rotation=45, ha=&#34;right&#34;,
                        rotation_mode=&#34;anchor&#34;)

        # Loop over data dimensions and create text annotations.
        # for i in range(len(x_vals)):
        #       for j in range(len(y_vals)):
        #               text = ax.text(j, i, data_im[i, j],
        #                                       ha=&#34;center&#34;, va=&#34;center&#34;, color=&#34;w&#34;)

        b, t = plt.ylim() # discover the values for bottom and top
        b += 0.5 # Add 0.5 to the bottom
        t -= 0.5 # Subtract 0.5 from the top
        plt.ylim(b, t) # update the ylim(bottom, top) values

        ax.set_title(&#34;Test Accuracy Varying Inhibition Scalars&#34;)
        fig.tight_layout()

        ax.set_xlabel(r&#34;$\lambda_1$&#34;)
        ax.set_ylabel(r&#34;$\lambda_2$&#34;).set_rotation(0)

        plt.tight_layout()
        plt.show()
        plt.savefig(&#39;heatmap.png&#39;)



def main(argv = sys.argv):
        if len(argv) &gt; 1:
                filename = argv[1]
        else:
                filename = &#39;data.df&#39;

        mode = &#39;hm&#39;
        if len(argv) &gt; 2:
                mode = argv[2]

        df = None
        if os.path.isfile(filename):
                df = pd.read_pickle(filename)
        else:
                from psweep.psweep_load import read_and_save
                df = read_and_save(filename)

        mx = 0.0
        mx_i = 0
        for i, v in enumerate(df[&#39;TEST_ACCURACY&#39;]):
                if v &gt; mx:
                        mx = v 
                        mx_i = i 

        print(df)
        print(mx, df[&#39;DIRNAME&#39;][mx_i])

        if mode == &#39;hm&#39;:
                plot_pair_heatmap(
                        df, &#39;LF_OUT&#39;, &#39;LF_HIDDEN&#39;,
                        others = {},
                        accuracy_mode = &#39;TEST_ACCURACY&#39;,
                )
        elif mode == &#39;table&#39;:
                save_sorted(df, os.path.dirname(filename) + &#39;/&#39;)
        elif mode == &#39;cr&#39;:
                print(compute_ranges(df))


def dynamic_load(filename : str, verbose : bool = True):
        df = None
        if os.path.isfile(filename):
                df = pd.read_pickle(filename)
        else:
                from psweep.psweep_load import read_and_save
                df = read_and_save(filename)

        if verbose:
                # REVIEW: what exactly does this do?
                mx = 0.0
                mx_i = 0
                for i, v in enumerate(df[&#39;TEST_ACCURACY&#39;]):
                        if v &gt; mx:
                                mx = v 
                                mx_i = i 

                print(df)
                print(mx, df[&#39;DIRNAME&#39;][mx_i])

        return df


def main_hm(filename : str = &#39;data.df&#39;, X : str = &#39;LF_OUT&#39;, Y : str = &#39;LF_HIDDEN&#39;, accuracy_mode : str = &#39;TEST_ACCURACY&#39;):
        &#34;&#34;&#34;plots a heatmap of the accuracy (`accuracy_mode`) dependent on `X,Y`
        
        # Parameters:
         - `filename : str`   
           pandas dataframe pickle file to look for. if not found, will try to generate and save it
           (defaults to `&#39;data.df&#39;`)
         - `X : str`   
           X axis variable for the heatmap. make sure that the specified dataframe file actually has this as a variable
           (defaults to `&#39;LF_OUT&#39;`)
         - `Y : str`   
           Y axis variable for the heatmap. make sure that the specified dataframe file actually has this as a variable
           (defaults to `&#39;LF_HIDDEN&#39;`)
         - `accuracy_mode : str`   
           the accuracy measure to plot on the heatmap
           (defaults to `&#39;TEST_ACCURACY&#39;`)
        &#34;&#34;&#34;
        df = dynamic_load(filename)

        plot_pair_heatmap(
                data = df, 
                X = X, Y = Y,
                others = {},
                accuracy_mode = accuracy_mode,
        )


def main_table(filename : str = &#39;data.df&#39;, sort_col : str = &#39;TEST_ACCURACY&#39;, save_path = None):
        &#34;&#34;&#34;outputs a table of the data from the given dataframe, sorted by `sort_col`
        
        # Parameters:
         - `filename : str`   
           pandas dataframe pickle file to look for. if not found, will try to generate and save it
           (defaults to `&#39;data.df&#39;`)
         - `sort_col : str`   
           [description]
           (defaults to `&#39;TEST_ACCURACY&#39;`)
         - `save_path : str`
           text file where the table should be saved. if `None`, saves to 
                `filename.split(&#39;.&#39;)[:-1] + &#39;_&#39; + sort_col + &#39;.txt&#39;`
           (defaults to `None`)
        &#34;&#34;&#34;
        if save_path is None:
                save_path = filename.split(&#39;.&#39;)[:-1] + &#39;_&#39; + sort_col + &#39;.txt&#39;

        df : pd.DataFrame = dynamic_load(filename)
        save_sorted(df, path = save_path, sort_col = sort_col)



def main_cr(filename : str = &#39;data.df&#39;):
        &#34;&#34;&#34;prints the ranges for the variables in the dataframe
        
        # Parameters:
         - `filename : str`   
           pandas dataframe pickle file to look for. if not found, will try to generate and save it
           (defaults to `&#39;data.df&#39;`)
        &#34;&#34;&#34;
        df : pd.DataFrame = dynamic_load(filename)
        print(compute_ranges(df))


MAIN_FUNCS = {
        &#39;heatmap&#39; : main_hm,
        &#39;hm&#39; : main_hm,
        &#39;table&#39; : main_table,
        &#39;compute_ranges&#39; : main_cr,
        &#39;cr&#39; : main_cr,
}

if __name__ == &#39;__main__&#39;:
        import fire
        fire.Fire(MAIN_FUNCS)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.compute_ranges"><code class="name flex">
<span>def <span class="ident">compute_ranges</span></span>(<span>df, cols_ignore=['CONFIG_ID', 'DIRNAME', 'LOSS_REL', 'LOSS_ABS', 'TEST_ACCURACY'], typemap={&#x27;RUN_ID&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;CONFIG_ID&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;DIRNAME&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;N_LAYER_0&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;N_LAYER_1&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;N_LAYER_2&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;DELTA_T&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;SIM_STEPS&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;BATCH_SIZE&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;MAX_EPOCHS&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;COUPLING_HIDDEN&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;COUPLING_OUT&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;LEARNING_RATE&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;OUTPUT_SCALAR&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;LF_HIDDEN&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;LF_OUT&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;NUM_SNIFFS&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;USE_BIAS&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;BETA_PHASE_2&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;GNA&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;GK&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;GL&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;ENA&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;EK&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;EL&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;LOSS_REL&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;LOSS_ABS&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;TEST_ACCURACY&#x27;: &lt;class &#x27;float&#x27;&gt;})</span>
</code></dt>
<dd>
<div class="desc"><p>takes in a dataframe, returns a 2-tuple of dicts:
(variable_ranges, consts)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_ranges(
                df,
                cols_ignore = REMOVE_COLS + [&#39;CONFIG_ID&#39;, &#39;DIRNAME&#39;] + [ k for k in LOSS_TYPES ],
                typemap = TYPE_MAP,
        ):
        &#34;&#34;&#34;
        takes in a dataframe, returns a 2-tuple of dicts:
        (variable_ranges, consts)
        &#34;&#34;&#34;
        
        # get all unique elements in each column
        ranges = {}
        for col in df.columns:
                if col not in cols_ignore:
                        is_floatCol = isinstance( typemap[col], float)
                        if is_floatCol:
                                ranges[col] = FloatSet()
                        else:
                                ranges[col] = set()
                        
                        for x in df[col]:
                                if is_floatCol:
                                        ranges[col].add_float(x)
                                else:
                                        ranges[col].add(x)

        var_ranges : Dict[str, List[float]] = {}
        consts : Dict[str, float] = {}

        for k in ranges:
                if len(ranges[k]) == 1:
                        # not variable
                        consts[k] = ranges[k].pop()
                else:
                        # variable
                        var_ranges[k] = sorted(list(ranges[k]))

        return (var_ranges, consts)</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.dynamic_load"><code class="name flex">
<span>def <span class="ident">dynamic_load</span></span>(<span>filename: str, verbose: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamic_load(filename : str, verbose : bool = True):
        df = None
        if os.path.isfile(filename):
                df = pd.read_pickle(filename)
        else:
                from psweep.psweep_load import read_and_save
                df = read_and_save(filename)

        if verbose:
                # REVIEW: what exactly does this do?
                mx = 0.0
                mx_i = 0
                for i, v in enumerate(df[&#39;TEST_ACCURACY&#39;]):
                        if v &gt; mx:
                                mx = v 
                                mx_i = i 

                print(df)
                print(mx, df[&#39;DIRNAME&#39;][mx_i])

        return df</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.fcomp"><code class="name flex">
<span>def <span class="ident">fcomp</span></span>(<span>a, b, delta=1e-05)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fcomp(a,b,delta = 1e-5):
        return abs(a-b) &lt; delta</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.load_pickled"><code class="name flex">
<span>def <span class="ident">load_pickled</span></span>(<span>filename='data.df')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pickled(filename = &#39;data.df&#39;):
        return pd.read_pickle(filename)</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>argv=['C:\\Program Files\\Python38\\Scripts\\pdoc', '--html', '.'])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(argv = sys.argv):
        if len(argv) &gt; 1:
                filename = argv[1]
        else:
                filename = &#39;data.df&#39;

        mode = &#39;hm&#39;
        if len(argv) &gt; 2:
                mode = argv[2]

        df = None
        if os.path.isfile(filename):
                df = pd.read_pickle(filename)
        else:
                from psweep.psweep_load import read_and_save
                df = read_and_save(filename)

        mx = 0.0
        mx_i = 0
        for i, v in enumerate(df[&#39;TEST_ACCURACY&#39;]):
                if v &gt; mx:
                        mx = v 
                        mx_i = i 

        print(df)
        print(mx, df[&#39;DIRNAME&#39;][mx_i])

        if mode == &#39;hm&#39;:
                plot_pair_heatmap(
                        df, &#39;LF_OUT&#39;, &#39;LF_HIDDEN&#39;,
                        others = {},
                        accuracy_mode = &#39;TEST_ACCURACY&#39;,
                )
        elif mode == &#39;table&#39;:
                save_sorted(df, os.path.dirname(filename) + &#39;/&#39;)
        elif mode == &#39;cr&#39;:
                print(compute_ranges(df))</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.main_cr"><code class="name flex">
<span>def <span class="ident">main_cr</span></span>(<span>filename: str = 'data.df')</span>
</code></dt>
<dd>
<div class="desc"><p>prints the ranges for the variables in the dataframe</p>
<h1 id="parameters">Parameters:</h1>
<ul>
<li><code>filename : str</code> <br>
pandas dataframe pickle file to look for. if not found, will try to generate and save it
(defaults to <code>'data.df'</code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main_cr(filename : str = &#39;data.df&#39;):
        &#34;&#34;&#34;prints the ranges for the variables in the dataframe
        
        # Parameters:
         - `filename : str`   
           pandas dataframe pickle file to look for. if not found, will try to generate and save it
           (defaults to `&#39;data.df&#39;`)
        &#34;&#34;&#34;
        df : pd.DataFrame = dynamic_load(filename)
        print(compute_ranges(df))</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.main_hm"><code class="name flex">
<span>def <span class="ident">main_hm</span></span>(<span>filename: str = 'data.df', X: str = 'LF_OUT', Y: str = 'LF_HIDDEN', accuracy_mode: str = 'TEST_ACCURACY')</span>
</code></dt>
<dd>
<div class="desc"><p>plots a heatmap of the accuracy (<code>accuracy_mode</code>) dependent on <code>X,Y</code></p>
<h1 id="parameters">Parameters:</h1>
<ul>
<li><code>filename : str</code> <br>
pandas dataframe pickle file to look for. if not found, will try to generate and save it
(defaults to <code>'data.df'</code>)</li>
<li><code>X : str</code> <br>
X axis variable for the heatmap. make sure that the specified dataframe file actually has this as a variable
(defaults to <code>'LF_OUT'</code>)</li>
<li><code>Y : str</code> <br>
Y axis variable for the heatmap. make sure that the specified dataframe file actually has this as a variable
(defaults to <code>'LF_HIDDEN'</code>)</li>
<li><code>accuracy_mode : str</code> <br>
the accuracy measure to plot on the heatmap
(defaults to <code>'TEST_ACCURACY'</code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main_hm(filename : str = &#39;data.df&#39;, X : str = &#39;LF_OUT&#39;, Y : str = &#39;LF_HIDDEN&#39;, accuracy_mode : str = &#39;TEST_ACCURACY&#39;):
        &#34;&#34;&#34;plots a heatmap of the accuracy (`accuracy_mode`) dependent on `X,Y`
        
        # Parameters:
         - `filename : str`   
           pandas dataframe pickle file to look for. if not found, will try to generate and save it
           (defaults to `&#39;data.df&#39;`)
         - `X : str`   
           X axis variable for the heatmap. make sure that the specified dataframe file actually has this as a variable
           (defaults to `&#39;LF_OUT&#39;`)
         - `Y : str`   
           Y axis variable for the heatmap. make sure that the specified dataframe file actually has this as a variable
           (defaults to `&#39;LF_HIDDEN&#39;`)
         - `accuracy_mode : str`   
           the accuracy measure to plot on the heatmap
           (defaults to `&#39;TEST_ACCURACY&#39;`)
        &#34;&#34;&#34;
        df = dynamic_load(filename)

        plot_pair_heatmap(
                data = df, 
                X = X, Y = Y,
                others = {},
                accuracy_mode = accuracy_mode,
        )</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.main_table"><code class="name flex">
<span>def <span class="ident">main_table</span></span>(<span>filename: str = 'data.df', sort_col: str = 'TEST_ACCURACY', save_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>outputs a table of the data from the given dataframe, sorted by <code>sort_col</code></p>
<h1 id="parameters">Parameters:</h1>
<ul>
<li><code>filename : str</code> <br>
pandas dataframe pickle file to look for. if not found, will try to generate and save it
(defaults to <code>'data.df'</code>)</li>
<li><code>sort_col : str</code> <br>
[description]
(defaults to <code>'TEST_ACCURACY'</code>)</li>
<li><code>save_path : str</code>
text file where the table should be saved. if <code>None</code>, saves to
<code>filename.split('.')[:-1] + '_' + sort_col + '.txt'</code>
(defaults to <code>None</code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main_table(filename : str = &#39;data.df&#39;, sort_col : str = &#39;TEST_ACCURACY&#39;, save_path = None):
        &#34;&#34;&#34;outputs a table of the data from the given dataframe, sorted by `sort_col`
        
        # Parameters:
         - `filename : str`   
           pandas dataframe pickle file to look for. if not found, will try to generate and save it
           (defaults to `&#39;data.df&#39;`)
         - `sort_col : str`   
           [description]
           (defaults to `&#39;TEST_ACCURACY&#39;`)
         - `save_path : str`
           text file where the table should be saved. if `None`, saves to 
                `filename.split(&#39;.&#39;)[:-1] + &#39;_&#39; + sort_col + &#39;.txt&#39;`
           (defaults to `None`)
        &#34;&#34;&#34;
        if save_path is None:
                save_path = filename.split(&#39;.&#39;)[:-1] + &#39;_&#39; + sort_col + &#39;.txt&#39;

        df : pd.DataFrame = dynamic_load(filename)
        save_sorted(df, path = save_path, sort_col = sort_col)</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.plot_pair_heatmap"><code class="name flex">
<span>def <span class="ident">plot_pair_heatmap</span></span>(<span>data, X, Y, others, ranges=None, accuracy_mode='LOSS_REL')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pair_heatmap(
                data,
                X, Y,
                others,
                ranges = None,
                # defaults = None,
                accuracy_mode = &#39;LOSS_REL&#39;,
        ):

        if ranges is None:
                ranges = compute_ranges(data)[0]

        print(ranges)
        
        # if defaults is None:
        #       defaults = CONSTS_DEFAULT


        # * trimming input dataframe

        # for everything in `others`, delete all dataframe elements that dont match
        for k in others:
                data = data.loc[ fcomp(data[k], others[k]) ]

        # dont need config ID or any of the default values
        del data[&#39;CONFIG_ID&#39;]

        for ot in others:
                del data[ot]

        # only need 1 type of loss
        for lt in LOSS_TYPES:
                if lt != accuracy_mode:
                        del data[lt]
        
        data_im = np.full(
                ( len(ranges[Y]), len(ranges[X]) ),
                np.nan,
                dtype=np.float
        )

        print(data)

        for i,x in enumerate(ranges[X]):
                for j,y in enumerate(ranges[Y]):
                        temp = data.loc[
                                fcomp(data[X], x)
                                &amp; fcomp(data[Y], y)
                        ][accuracy_mode]

                        if temp.empty:
                                data_im[j,i] = np.nan
                        else:
                                data_im[j,i] = temp.to_list()[0]                        
                        
        # * chart stuff

        x_vals = ranges[X]
        y_vals = ranges[Y]

        fig, ax = plt.subplots()
        im = ax.imshow(data_im, cmap=&#34;inferno&#34;)
        cbar = plt.colorbar(im)
        cbar.ax.set_ylabel(accuracy_mode, rotation=-90, va=&#34;bottom&#34;)

        # We want to show all ticks...
        ax.set_xticks(np.arange(len(x_vals)))
        ax.set_yticks(np.arange(len(y_vals)))

        # ... and label them with the respective list entries
        ax.set_xticklabels([str(round(x_vals[i], 2)) if (i == len(x_vals) - 1 or i % 5 == 0) else &#34;&#34; for i in range(len(x_vals))])
        ax.set_yticklabels([str(round(y_vals[i], 2)) if (i == len(y_vals) - 1 or i % 5 == 0) else &#34;&#34; for i in range(len(y_vals))])

        # Rotate the tick labels and set their alignment.
        plt.setp(ax.get_xticklabels(), rotation=45, ha=&#34;right&#34;,
                        rotation_mode=&#34;anchor&#34;)

        # Loop over data dimensions and create text annotations.
        # for i in range(len(x_vals)):
        #       for j in range(len(y_vals)):
        #               text = ax.text(j, i, data_im[i, j],
        #                                       ha=&#34;center&#34;, va=&#34;center&#34;, color=&#34;w&#34;)

        b, t = plt.ylim() # discover the values for bottom and top
        b += 0.5 # Add 0.5 to the bottom
        t -= 0.5 # Subtract 0.5 from the top
        plt.ylim(b, t) # update the ylim(bottom, top) values

        ax.set_title(&#34;Test Accuracy Varying Inhibition Scalars&#34;)
        fig.tight_layout()

        ax.set_xlabel(r&#34;$\lambda_1$&#34;)
        ax.set_ylabel(r&#34;$\lambda_2$&#34;).set_rotation(0)

        plt.tight_layout()
        plt.show()
        plt.savefig(&#39;heatmap.png&#39;)</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.save_sorted"><code class="name flex">
<span>def <span class="ident">save_sorted</span></span>(<span>df: pandas.core.frame.DataFrame, path: str = '', sort_col: str = 'TEST_ACCURACY')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_sorted(df : pd.DataFrame, path : str = &#39;&#39;, sort_col : str = &#39;TEST_ACCURACY&#39;):
        with open(path, &#39;w&#39;) as fout:
                print(df.sort_values(sort_col), file=fout)</code></pre>
</details>
</dd>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.save_sorted_many"><code class="name flex">
<span>def <span class="ident">save_sorted_many</span></span>(<span>df, basepath='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_sorted_many(df, basepath = &#39;&#39;):
        pd.set_option(&#39;display.max_rows&#39;, None)
        pd.set_option(&#39;display.max_columns&#39;, 50)
        pd.set_option(&#39;display.width&#39;, None)
        pd.set_option(&#39;display.max_colwidth&#39;, 500)

        with open(basepath + &#39;loss_rel.txt&#39;, &#39;w&#39;) as fout:
                print(df.sort_values(&#39;LOSS_REL&#39;), file=fout)

        with open(basepath + &#39;loss_abs.txt&#39;, &#39;w&#39;) as fout:
                print(df.sort_values(&#39;LOSS_ABS&#39;), file=fout)

        with open(basepath + &#39;test_acc.txt&#39;, &#39;w&#39;) as fout:
                print(df.sort_values(&#39;TEST_ACCURACY&#39;), file=fout)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.FloatSet"><code class="flex name class">
<span>class <span class="ident">FloatSet</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>set() -&gt; new empty set object
set(iterable) -&gt; new set object</p>
<p>Build an unordered collection of unique elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FloatSet(set):
        def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)

        def add_float(self, myfloat : float, delta = 1e-5):
                if all( (not fcomp(x, myfloat, delta)) for x in self ):
                        self.add(myfloat)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.set</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="BNBP-public.HH-SGD.psweep.plot_psweep.FloatSet.add_float"><code class="name flex">
<span>def <span class="ident">add_float</span></span>(<span>self, myfloat: float, delta=1e-05)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_float(self, myfloat : float, delta = 1e-5):
        if all( (not fcomp(x, myfloat, delta)) for x in self ):
                self.add(myfloat)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="BNBP-public.HH-SGD.psweep" href="index.html">BNBP-public.HH-SGD.psweep</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.compute_ranges" href="#BNBP-public.HH-SGD.psweep.plot_psweep.compute_ranges">compute_ranges</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.dynamic_load" href="#BNBP-public.HH-SGD.psweep.plot_psweep.dynamic_load">dynamic_load</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.fcomp" href="#BNBP-public.HH-SGD.psweep.plot_psweep.fcomp">fcomp</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.load_pickled" href="#BNBP-public.HH-SGD.psweep.plot_psweep.load_pickled">load_pickled</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.main" href="#BNBP-public.HH-SGD.psweep.plot_psweep.main">main</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.main_cr" href="#BNBP-public.HH-SGD.psweep.plot_psweep.main_cr">main_cr</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.main_hm" href="#BNBP-public.HH-SGD.psweep.plot_psweep.main_hm">main_hm</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.main_table" href="#BNBP-public.HH-SGD.psweep.plot_psweep.main_table">main_table</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.plot_pair_heatmap" href="#BNBP-public.HH-SGD.psweep.plot_psweep.plot_pair_heatmap">plot_pair_heatmap</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.save_sorted" href="#BNBP-public.HH-SGD.psweep.plot_psweep.save_sorted">save_sorted</a></code></li>
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.save_sorted_many" href="#BNBP-public.HH-SGD.psweep.plot_psweep.save_sorted_many">save_sorted_many</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.FloatSet" href="#BNBP-public.HH-SGD.psweep.plot_psweep.FloatSet">FloatSet</a></code></h4>
<ul class="">
<li><code><a title="BNBP-public.HH-SGD.psweep.plot_psweep.FloatSet.add_float" href="#BNBP-public.HH-SGD.psweep.plot_psweep.FloatSet.add_float">add_float</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>